---
layout: default
title:  "TLS安全套件概述与实践"
description: ""
date: 2020-01-06 6:00:00 +0800
categories: fend
---

HTTP协议传输的文本是明文的，任何中间代理都可以获悉client与server传输的信息，毫无保密性可言。而且，HTTP协议没有校验通信双方的身份、没有校验数据是否被篡改过，这就意味着中间代理可以冒充服务器或客户端，向双方发出错误的指令。SSL/TLS的目的就是解决这些安全问题。
按照通用的说法，SSL/TLS在TCP/IP模型中的位置属于"安全套接层"——位于运输层和应用层中间。SSL/TLS发展历程比较复杂，可以将TLS协议看作是SSL协议的升级版，本文介绍的是TLS协议相关的安全套件。文章只介绍基本的概念和通信的流程，不研究涉及的加密算法，所以细节方面一定是不足的。在文章末尾，我会讲解如何使用`openssl`和`nginx`搭建简单的抓包实验，以加深读者对整个TLS通信流程的理解。

todo: 这里插一张TCP/IP分层的图

## 术语
这些术语对理解数据的加解密十分关键，我先简单地介绍这些概念，随着文章的深入你会理解它们，建议先简单过一遍，后文提到了再回顾。
- **密码**：不同于我们日常理解的"密码"（应当称之为"口令"），专业上的"密码"是一种算法，相当于function：`密码(明文) = 密文`。比如，我们把用户的口令存储为`md5(口令)`，这里的`md5()`就是密码。
- **密钥**：我们可以在不同的应用中使用不同的密码（加密算法），但是为了使得加密具有独特性，还得引入一个新的变量，那么加密的function是这样的：`密码(密钥，明文) = 密文`。
- **对称秘钥加密**：使用同一个密钥，既可以将明文加密为密文、也可以将密文解密为明文。听上去是不是有些不可思议，其实它的基本原理是简单的异或操作，感兴趣的读者可以自行搜索。
- **非对称密钥加密**：使用不同的密钥A和B，A可以解密用密钥B加密的密文，反过来，B也可以解密用密钥A加密的密文。但是，A无法解密密钥A加密的密文，B也无法解密密钥B加密的密文。
- **公开密钥加密**：字面意思，就是使用公开的密钥加密。公开密钥加密一般与非对称密钥加密一起用，例如公开密钥A并称之为**公钥**，密钥B称之为**私钥**，那么使用公钥加密的数据，除了掌握私钥的人谁也无法解密。
- **数字签名**：
- **数字证书**：

## 初识TLS安全套件
针对上文提到的HTTP协议的缺陷，TLS安全套件提供了一套组合拳来保护客户端与服务端的整个通信流程。这些套件包括：
1. 身份验证算法。在发送数据之前，客户端需要验证服务端的身份（某些应用服务端也要验证客户端的身份，本文只讲一般的场景）。
2. 加密算法。解决通信过程中数据的保密问题，在TLS套件中用的是对称密钥加密算法。
2. 密钥交换算法。对称密钥加密算法需要双方约定一个对称密钥，这个算法就是用于协商密钥的。
3. 签名hash算法。用于TLS握手期间，防止身份验证和密钥交换的数据被篡改。

todo：插入一张TLS的通信图。

这是TLS的整个通信流程，包括身份验证、选用安全套件、交换密钥并生成加密密钥、加密通信。接下来我会介绍每一个套件在通信流程中是如何发挥作用的，最后会回过头来强化理解这张通信图。

## 步骤一：通信前的身份验证
在TCP握手成功后，客户端和服务端会开始协商安全套件，协商安全套件的第一步，就是验证对方的身份（本场景特指客户端验证服务器的身份）。身份认证依赖于PKI(Public Key Infrastructure，公钥基础设施)，而PKI是脱胎于非对称密钥加密技术的，了解非对称加密技术是理解身份验证步骤的关键。

### 数字签名
非对称加密有两个密钥：私钥和公钥，私钥放到服务端，公钥放到客户端。在TLS的握手阶段（也就是验证身份的阶段），先由客户端发送协商信息给服务端，服务端在回复之前，会以回复的数据生成一串哈希值A，并使用私钥加密，我们将加密后的值称为"**数字签名**"，数字签名会附加到回复的数据中。
客户端收到返回的数据后，会取出数字签名，使用公钥解密数据，得到那串哈希值A。然后，客户端会用同样的哈希算法对数据加密，得到一串哈希值B。只要哈希值A与哈希值B相同，就可以认为这次通信返回的数据是真正的服务器返回的。

todo: 插入一张签名和验证签名的图

### 数字证书
如果你点击浏览器地址栏左边的https安全标识，会看到数字证书，仔细浏览，可以发现证书里面有公钥信息。
todo: 插入一张证书

这本数字证书是怎么来的呢？在开发者生成私钥和公钥之后，需要将密钥、站点、组织的信息提交给证书登记机构，由证书机构颁发证书。这本证书会存放到两个地方：OCSP在线查询服务和开发者的服务器。在TLS的握手阶段，服务端不仅仅会返回协商的安全套件信息和数字签名，还有数字证书，所以整个签名和验签的流程是这样的：

todo: 插入一张签名和验证签名的图

### 公钥基础设施
客户端收到数字证书后，会访问OCSP在线查询服务校验证书的合法性。因为这次通信有数字签名保障服务端的身份，只要证书是合法的（注册过而且没过期），那么证书里面的公钥就是可用的。有的读者可能会问，如果中间代理换了另一本合法的证书，不就有安全风险了吗？虽然证书是合法的，但是证书的公钥解密签名得到的哈希值是错误的，会导致身份验证失败，所以不会有这方面的安全风险。
由证书登记机构、颁发机构以及颁发机构提供的查询服务，我们称之为PKI(Public Key Infrastructure，公钥基础设施)。PKI与服务端签名、客户端验签的整个流程如这张图所示：

todo: 插入PKI设施图

至此，我们了解了TLS握手阶段身份验证的流程。TLS安全套件中常用的非对称加密算法RSA算法，上述提到的私钥加密和公钥解密用到的就是这种算法，因为签名和验签是身份验证的关键，所以我们也可以称RSA算法为TLS安全套件中的身份验证算法。RSA算法的原理本文不做任何讲解。

## 步骤二：协商加密算法
握手阶段除了身份验证，还需要协商加密通信数据用的算法。上一节提到的RSA算法和公私钥，一般不用于通信数据的加解密，因为这两个原因：
1. RSA算法加解密的时间比较长，不适合用于频繁的数据通信。
2. 私钥有泄漏和暴力破解的风险，虽然在RSA的加持下破解成本很高、用时很长，但是总有被未来更高性能的计算机破解的一天。如果数据通信也使用了这对公私钥，那么私钥泄漏就相当于公开了历史的所有通信数据，用业界术语描述就是没有"前向保密性"。

我们可以想象到通信用的加密算法必须克服以上的两个缺点，也就是加密效率高、具备前向保密性。针对加密效率，TLS安全套件用了对称加密技术，常用的算法如AES算法，本文也不解释AES算法的原理，读者只需要知道其概念和作用即可；针对前向保密性，TLS安全套件使用了DH密钥交换的技术。

### DH密钥交换
对称加密技术只有一个密钥，供服务端和客户端共同使用，使用这个密钥的AES算法可以实现双向的加解密。为了实现前向保密性，这个密钥必须是临时的而非永久的，只能短期内使用，所以除了协商好加密算法，还要协商加密的秘钥。DH密钥交换技术简介（暂略）。下图是密钥交换的流程：

todo: 插一张密钥交换的流程图

1. 服务端确定了选用的安全套件后，会生成一对临时的公私钥A1和B1（跟RSA算法的公私钥不一样），然后将其中的公钥B1返回给客户端。
2. 客户端获悉选用的安全套件后，也会生成一对临时的公私钥A2和B2，并使用私钥A2和接收到的公钥B1计算得到密钥C，然后将公钥B2发送给服务端。
3. 服务端接收到公钥B2后，用它与私钥A1计算得出密钥C。没错，这个密钥C与客户端计算得到的密钥C是同一个密钥。
经过这三步，客户端和服务端就具备了一样的密钥，可以使用AES算法对客户端或服务端的数据加解密了。
值得一提的是，交换密钥的过程为了防止中间人攻击（即中间代理自己生成一对公私钥，分别向客户端和服务端发送公钥，从而生成两个密钥，它们分别跟客户端与服务端的密钥相同，具备两方数据的能力），服务端会在身份认证时将公钥放到协商数据里，中间代理就无法伪装成客户端了。

todo: 插一张中间人攻击的图吧



### 原理部分

- 术语
- TLS组成

	- 设计目的
	- 每一个组成的简介
	- 大致的流程图

		- 就跟vue介绍生命周期一样，提示先记住这张图，后面学到的时候回顾一下

- 了解组成的每一部分

	- AES

		- 对称加密
		- 基本原理
		- 好处

			- 加解密时间比RSA短，相同的强度下长度也短一些

		- 坏处

			- 需要客户端和服务端协商，无法在初次通信就使用

		- 用途

			- 在http事务中对数据加密

	- ECDHE

		- 由AES引出
		- 基本原理

	- SHA256
	- RSA

		- 非对称加密
		- 基本的原理
		- 好处

			- 破解难度高
			- 有公私钥，适合作为初次通信的加密

		- 坏处

			- 速度慢

		- 用途

			- 作为签名证书的一部分，用于身份验证

	- 数字证书

		- 基于RSA

	- 细说TLS套件及流程：将以上知识点串讲，回顾文章开头的图

- 把控讲解的深度

	- 避免数学部分，这一点可以参考http权威指南
	- 但是要为被忽略的知识点找到原始的资料，例如标准文档，方便查证与深入

### 实践部分

- 服务都部署在本地吧，通过代理来访问
- openssl

	- 附上指令文档地址

		- https://ningyu1.github.io/site/post/51-ssl-cert/

- nginx

	- nginx帮我们处理了握手和加密的流程，配置简单
	- 附上指令文档地址

		- http://nginx.org/en/docs/beginners_guide.html
		- https://aotu.io/notes/2016/08/16/nginx-https/index.html
		- https://nginx.org/en/docs/http/ngx_http_ssl_module.html
		- https://nginx.org/en/docs/http/configuring_https_servers.html

- node

	- 太麻烦了，就不在这里作为示例了

- wireshark: 最后还得抓包验证原理部分的讲述

	- 附上mac/win的https抓包教程
	- https://imququ.com/post/how-to-decrypt-https.html
	- https://imququ.com/post/http2-traffic-in-wireshark.html

### 因为涉及的文档太多，就像写论文一样，把引用文档列到最后吧

